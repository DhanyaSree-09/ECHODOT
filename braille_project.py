# -*- coding: utf-8 -*-
"""Braille Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1clmtTM9ihmrm8zqBP0l9Gxtili_xTZ5X

BRAILLE PROJECT MAIN CODE
"""

!pip install gTTS

"""TEXT TO IMAGE"""

from PIL import Image, ImageDraw
import numpy as np
from google.colab import files
import ipywidgets as widgets
from IPython.display import display, clear_output

# Braille mapping from letters to dot sets
LETTER_TO_DOTS = {
    'A': {1}, 'B': {1, 2}, 'C': {1, 4}, 'D': {1, 4, 5}, 'E': {1, 5},
    'F': {1, 2, 4}, 'G': {1, 2, 4, 5}, 'H': {1, 2, 5}, 'I': {2, 4},
    'J': {2, 4, 5}, 'K': {1, 3}, 'L': {1, 2, 3}, 'M': {1, 3, 4},
    'N': {1, 3, 4, 5}, 'O': {1, 3, 5}, 'P': {1, 2, 3, 4}, 'Q': {1, 2, 3, 4, 5},
    'R': {1, 2, 3, 5}, 'S': {2, 3, 4}, 'T': {2, 3, 4, 5}, 'U': {1, 3, 6},
    'V': {1, 2, 3, 6}, 'W': {2, 4, 5, 6}, 'X': {1, 3, 4, 6}, 'Y': {1, 3, 4, 5, 6},
    'Z': {1, 3, 5, 6}, ' ': set(), ',': {2}, '.': {2, 5, 6}
}

def letter_to_braille_dots(letter):
    return LETTER_TO_DOTS.get(letter.upper(), set())

def generate_braille_image(text):
    cell_width = 40
    cell_height = 60
    dot_radius = 7
    padding = 10

    dot_positions = [
        (cell_width // 4, cell_height // 6),
        (cell_width // 4, cell_height // 2),
        (cell_width // 4, 5 * cell_height // 6),
        (3 * cell_width // 4, cell_height // 6),
        (3 * cell_width // 4, cell_height // 2),
        (3 * cell_width // 4, 5 * cell_height // 6)
    ]

    num_chars = len(text)
    img_width = cell_width * num_chars + padding * 2
    img_height = cell_height + padding * 2

    image = Image.new('L', (img_width, img_height), color=255)
    draw = ImageDraw.Draw(image)

    for i, ch in enumerate(text):
        dots = letter_to_braille_dots(ch)
        x_start = i * cell_width + padding

        for dot_num in range(1, 7):
            x, y = dot_positions[dot_num - 1]
            cx, cy = x_start + x, padding + y
            if dot_num in dots:
                draw.ellipse(
                    (cx - dot_radius, cy - dot_radius, cx + dot_radius, cy + dot_radius),
                    fill=0
                )

    return image

# UI: Text input and button
text_input = widgets.Text(
    value='',
    description='Enter Text:',
    layout=widgets.Layout(width='100%')
)

generate_button = widgets.Button(
    description='Generate Braille Image',
    button_style='primary'
)

output = widgets.Output()

def on_generate_clicked(b):
    with output:
        clear_output()
        text = text_input.value
        braille_image = generate_braille_image(text)
        file_path = "braille_output.png"
        braille_image.save(file_path)
        display(braille_image)
        print("✅ Click below to download the Braille image:")
        files.download(file_path)

generate_button.on_click(on_generate_clicked)

display(widgets.VBox([text_input, generate_button, output]))

"""MODIFIED TEXT TO IMG

"""

from PIL import Image, ImageDraw
import numpy as np
from google.colab import files
import ipywidgets as widgets
from IPython.display import display, clear_output

# 🟦 Braille mapping (letters → dot positions)
LETTER_TO_DOTS = {
    'A': {1}, 'B': {1, 2}, 'C': {1, 4}, 'D': {1, 4, 5}, 'E': {1, 5},
    'F': {1, 2, 4}, 'G': {1, 2, 4, 5}, 'H': {1, 2, 5}, 'I': {2, 4},
    'J': {2, 4, 5}, 'K': {1, 3}, 'L': {1, 2, 3}, 'M': {1, 3, 4},
    'N': {1, 3, 4, 5}, 'O': {1, 3, 5}, 'P': {1, 2, 3, 4}, 'Q': {1, 2, 3, 4, 5},
    'R': {1, 2, 3, 5}, 'S': {2, 3, 4}, 'T': {2, 3, 4, 5}, 'U': {1, 3, 6},
    'V': {1, 2, 3, 6}, 'W': {2, 4, 5, 6}, 'X': {1, 3, 4, 6}, 'Y': {1, 3, 4, 5, 6},
    'Z': {1, 3, 5, 6}, ' ': set(), ',': {2}, '.': {2, 5, 6}
}

# 🟩 Convert dots → Unicode Braille character
def dots_to_unicode(dots):
    base = 0x2800  # Unicode Braille Pattern Blank
    code = base
    for dot in dots:
        code += 1 << (dot - 1)
    return chr(code)

# 🟩 Get dot pattern for a given letter
def letter_to_braille_dots(letter):
    return LETTER_TO_DOTS.get(letter.upper(), set())

# 🟩 Generate Braille text and image
def generate_braille_image_and_text(text):
    cell_width = 40
    cell_height = 60
    dot_radius = 7
    padding = 10

    dot_positions = [
        (cell_width // 4, cell_height // 6),
        (cell_width // 4, cell_height // 2),
        (cell_width // 4, 5 * cell_height // 6),
        (3 * cell_width // 4, cell_height // 6),
        (3 * cell_width // 4, cell_height // 2),
        (3 * cell_width // 4, 5 * cell_height // 6)
    ]

    num_chars = len(text)
    img_width = cell_width * num_chars + padding * 2
    img_height = cell_height + padding * 2

    image = Image.new('L', (img_width, img_height), color=255)
    draw = ImageDraw.Draw(image)

    braille_text = ""

    for i, ch in enumerate(text):
        dots = letter_to_braille_dots(ch)
        braille_text += dots_to_unicode(dots)  # convert to Unicode Braille symbol
        x_start = i * cell_width + padding

        for dot_num in range(1, 7):
            x, y = dot_positions[dot_num - 1]
            cx, cy = x_start + x, padding + y
            if dot_num in dots:
                draw.ellipse(
                    (cx - dot_radius, cy - dot_radius, cx + dot_radius, cy + dot_radius),
                    fill=0
                )

    return image, braille_text

# 🟩 UI widgets
text_input = widgets.Text(
    value='',
    description='Enter Text:',
    layout=widgets.Layout(width='100%')
)

generate_button = widgets.Button(
    description='Generate Braille (Image + Text)',
    button_style='primary'
)

output = widgets.Output()

# 🟩 On button click
def on_generate_clicked(b):
    with output:
        clear_output()
        text = text_input.value
        braille_image, braille_text = generate_braille_image_and_text(text)
        file_path = "braille_output.png"
        braille_image.save(file_path)

        print("🔤 English Text:", text)
        print("⠿ Braille Text:", braille_text)
        display(braille_image)
        print("\n✅ Click below to download the Braille image:")
        files.download(file_path)

generate_button.on_click(on_generate_clicked)

display(widgets.VBox([text_input, generate_button, output]))

"""MODIFIED IMG TO SPEECH"""

from PIL import Image
import numpy as np
from gtts import gTTS
import IPython.display as ipd
from google.colab import files
from IPython.display import display

# Braille mapping
LETTER_TO_DOTS = {
    'A': {1}, 'B': {1, 2}, 'C': {1, 4}, 'D': {1, 4, 5}, 'E': {1, 5},
    'F': {1, 2, 4}, 'G': {1, 2, 4, 5}, 'H': {1, 2, 5}, 'I': {2, 4},
    'J': {2, 4, 5}, 'K': {1, 3}, 'L': {1, 2, 3}, 'M': {1, 3, 4},
    'N': {1, 3, 4, 5}, 'O': {1, 3, 5}, 'P': {1, 2, 3, 4}, 'Q': {1, 2, 3, 4, 5},
    'R': {1, 2, 3, 5}, 'S': {2, 3, 4}, 'T': {2, 3, 4, 5}, 'U': {1, 3, 6},
    'V': {1, 2, 3, 6}, 'W': {2, 4, 5, 6}, 'X': {1, 3, 4, 6}, 'Y': {1, 3, 4, 5, 6},
    'Z': {1, 3, 5, 6}, ' ': set(), ',': {2}, '.': {2, 5, 6}
}
DOTS_TO_LETTER = {frozenset(v): k for k, v in LETTER_TO_DOTS.items()}

# Braille Unicode mapping
UNICODE_TO_LETTER = {
    '⠁':'A','⠃':'B','⠉':'C','⠙':'D','⠑':'E','⠋':'F','⠛':'G','⠓':'H',
    '⠊':'I','⠚':'J','⠅':'K','⠇':'L','⠍':'M','⠝':'N','⠕':'O','⠏':'P',
    '⠟':'Q','⠗':'R','⠎':'S','⠞':'T','⠥':'U','⠧':'V','⠺':'W','⠭':'X',
    '⠽':'Y','⠵':'Z',' ':' ','⠂':',','⠲':'.'
}

# Decode Braille Image
def decode_braille_image(img_path):
    img = Image.open(img_path).convert('L')
    arr = np.array(img)
    h, w = arr.shape
    bin_img = arr < 100
    cw, ch, dr, pad = 40, 60, 7, 10
    num_cells = (w - pad*2) // cw
    dot_pos = [(cw//4, ch//6),(cw//4, ch//2),(cw//4,5*ch//6),
               (3*cw//4,ch//6),(3*cw//4,ch//2),(3*cw//4,5*ch//6)]
    text = []
    for ci in range(num_cells):
        x_start = ci*cw + pad
        dots = set()
        for idx, (dx, dy) in enumerate(dot_pos, 1):
            x, y = x_start+dx, pad+dy
            if y<h and x<w:
                region = bin_img[max(0,y-dr):min(h,y+dr), max(0,x-dr):min(w,x+dr)]
                if np.any(region): dots.add(idx)
        text.append(DOTS_TO_LETTER.get(frozenset(dots), ' '))  # Replace unknown dots with space
    return ''.join(text).strip()

# Braille Unicode input
def decode_unicode_braille(unicode_str):
    return ''.join(UNICODE_TO_LETTER.get(ch,' ') for ch in unicode_str)  # Replace unknown with space

# Clean text for TTS
def clean_text_for_speech(text):
    text = text.replace('?', ' ')
    text = ' '.join(text.split())
    return text

# Text to Speech
def speak(text):
    clean_text = clean_text_for_speech(text)
    if clean_text:
        tts = gTTS(text=clean_text, lang='en')
        tts.save("output.mp3")
        return ipd.Audio("output.mp3", autoplay=True)

# === Main Choice ===
choice = input("Do you want to input a (1) Braille Image or (2) Braille Unicode? Enter 1 or 2: ")

if choice == '1':
    print("Upload a Braille image:")
    uploaded = files.upload()
    img_path = next(iter(uploaded))
    decoded_text = decode_braille_image(img_path)
    print("Decoded Text from Image:", clean_text_for_speech(decoded_text))
    display(speak(decoded_text))
elif choice == '2':
    unicode_input = input("Enter Braille Unicode (⠁⠃ etc.): ")
    text_from_unicode = decode_unicode_braille(unicode_input)
    print("Decoded Text from Unicode:", clean_text_for_speech(text_from_unicode))
    display(speak(text_from_unicode))
else:
    print("Invalid choice! Please enter 1 or 2.")

"""IMG TO SPEECH"""

from PIL import Image, ImageDraw
import numpy as np
from gtts import gTTS
import IPython.display as ipd
from google.colab import files
from IPython.display import display

# Braille mapping from letters to dot sets
LETTER_TO_DOTS = {
    'A': {1}, 'B': {1, 2}, 'C': {1, 4}, 'D': {1, 4, 5}, 'E': {1, 5},
    'F': {1, 2, 4}, 'G': {1, 2, 4, 5}, 'H': {1, 2, 5}, 'I': {2, 4},
    'J': {2, 4, 5}, 'K': {1, 3}, 'L': {1, 2, 3}, 'M': {1, 3, 4},
    'N': {1, 3, 4, 5}, 'O': {1, 3, 5}, 'P': {1, 2, 3, 4}, 'Q': {1, 2, 3, 4, 5},
    'R': {1, 2, 3, 5}, 'S': {2, 3, 4}, 'T': {2, 3, 4, 5}, 'U': {1, 3, 6},
    'V': {1, 2, 3, 6}, 'W': {2, 4, 5, 6}, 'X': {1, 3, 4, 6}, 'Y': {1, 3, 4, 5, 6},
    'Z': {1, 3, 5, 6}, ' ': set(), ',': {2}, '.': {2, 5, 6}
}

# Reverse mapping from dot sets to letters
DOTS_TO_LETTER = {frozenset(v): k for k, v in LETTER_TO_DOTS.items()}

# Function to decode Braille image
def decode_braille_image(image_path):
    image = Image.open(image_path).convert('L')
    image_array = np.array(image)
    height, width = image_array.shape

    threshold = 100
    binary_image = image_array < threshold

    cell_width = 40
    cell_height = 60
    dot_radius = 7
    padding = 10
    num_cells = (width - padding * 2) // cell_width

    dot_positions = [
        (cell_width // 4, cell_height // 6),        # Dot 1
        (cell_width // 4, cell_height // 2),        # Dot 2
        (cell_width // 4, 5 * cell_height // 6),    # Dot 3
        (3 * cell_width // 4, cell_height // 6),    # Dot 4
        (3 * cell_width // 4, cell_height // 2),    # Dot 5
        (3 * cell_width // 4, 5 * cell_height // 6) # Dot 6
    ]

    translated_text = []

    for cell_idx in range(num_cells):
        x_start = cell_idx * cell_width + padding
        dots_present = set()

        for idx, (dx, dy) in enumerate(dot_positions, 1):
            x = x_start + dx
            y = padding + dy
            if y < height and x < width:
                region = binary_image[max(0, y - dot_radius):min(height, y + dot_radius),
                                      max(0, x - dot_radius):min(width, x + dot_radius)]
                if np.any(region):
                    dots_present.add(idx)

        letter = DOTS_TO_LETTER.get(frozenset(dots_present), '?')
        translated_text.append(letter)

    final_text = ''.join(translated_text).strip()
    return final_text

# Function for text-to-speech
def text_to_speech(text, filename="output.mp3"):
    if text and any(c.isalpha() for c in text):
        tts = gTTS(text=text, lang='en')
        tts.save(filename)
        return ipd.Audio(filename, autoplay=True)
    else:
        return None

# === Upload and Process ===
uploaded = files.upload()
image_path = next(iter(uploaded))  # Get the uploaded file name
decoded_text = decode_braille_image(image_path)
audio = text_to_speech(decoded_text)

if audio:
    display(audio)

"""ACCURACY"""

from sklearn.metrics import precision_score, recall_score, f1_score

# 🟩 Step 1: Take user input
actual_text = input("Enter the actual (expected) English text: ").strip().upper()
predicted_text = input("Enter the predicted (output) English text: ").strip().upper()

# 🟩 Step 2: Character-level accuracy
min_len = min(len(actual_text), len(predicted_text))
correct_chars = sum(1 for i in range(min_len) if actual_text[i] == predicted_text[i])
char_accuracy = (correct_chars / len(actual_text)) * 100 if len(actual_text) > 0 else 0

# 🟩 Step 3: Word-level accuracy
actual_words = actual_text.split()
predicted_words = predicted_text.split()
min_len_words = min(len(actual_words), len(predicted_words))
correct_words = sum(1 for i in range(min_len_words) if actual_words[i] == predicted_words[i])
word_accuracy = (correct_words / len(actual_words)) * 100 if len(actual_words) > 0 else 0

# 🟩 Step 4: Precision, Recall, F1-Score (character-based)
# Convert to binary: 1 for correct match, 0 for mismatch
y_true = [1] * min_len  # expected truth
y_pred = [1 if actual_text[i] == predicted_text[i] else 0 for i in range(min_len)]

if len(y_pred) > 0:
    precision = precision_score(y_true, y_pred)
    recall = recall_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
else:
    precision = recall = f1 = 0

# 🟩 Step 5: Display results
print("\n📊 --- Accuracy Results ---")
print(f"Character-level Accuracy: {char_accuracy:.2f}%")
print(f"Word-level Accuracy: {word_accuracy:.2f}%")
print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}")